#!/usr/bin/env python3

###### ----- THIS SCRIPT IS USED FOR exercise4.md

import socket
import os
import sys
import time
import string
from optparse import OptionParser
from optparse import OptionGroup
import struct




##### Helper Functions #####

# decodes a hex encoded string into bytes
# E.g., decode_hex('3031323334')
#		returns b'01234'
def decode_hex(data):
	if not len(data) % 2 == 0:
		print('ERROR in decode_hex: data must have an even number of characters')
		# I could exit here, but I'll let this throw an exception
		# for the stack trace
	return  bytes.fromhex(data)


# oposite of decode_hex
# data must be bytes
# E.g., encode_hex(b'1234')
#		returns '31323334'
def encode_hex(data):
	return data.hex()



##### Ethernet/IP class #####
###
### Class for handling ENIP sessions and sequence numbers and such
###
class ENIP:

	# Connect to the PLC and register a session
	def connect(self, ip, port, slot):
		self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.sock.connect((ip, port))	
		self.register_session()
		self.slot = slot
		self.context = 0
		
		
	# Send the given packet (no modifications are made prior to sending
	def send(self, packet):
		self.sock.send(packet)
	
	# Get the response from the PLC
	def recv(self):
		return self.sock.recv(65536)


	# Registers an ENIP session with the PLC
	def register_session(self):

		reg = decode_hex('65000400000000000000000000000000000000000000000001000000')
		
		self.send(reg)
	
		response = self.recv()
		self.session = response[4:8]
	
		# The session ID is stored in self.session
		# in a format ready for wrapENIPHeader
		return self.session
		

	# Prepends the ENIP "Encapsulation Header" to the packet
	def wrapENIPHeader(self, data, command=b'\x70\x00'):
	
		context = struct.pack('<Q', self.context)
		leng = struct.pack('<H', len(data))
		status = b'\x00\x00\x00\x00'
		options = b'\x00\x00\x00\x00'
	
		header = command + leng + self.session + status + context + options
		return header + data


	# Prepends the ENIP "Command Specific Data" header
	def wrapCIPHeader(self, data):
		hdr = decode_hex('000000000a00020000000000b200')
		
		leng = struct.pack('<H', len(data))
		
		pkt = hdr + leng + data
		
		return pkt
		

	# This expects the bytes from "PCCC Command Data" field in Wireshark
	def send_pccc_object(self, data):
		
		p = e.wrapCIPHeader(data)
		
		p = e.wrapENIPHeader(p, b'\x6F\x00')
		e.send(p)
		return e.recv()




##### CLI Options #####


parser = OptionParser()

# Change the default IP address to that of your PLC
# TODO: Check these defaults
parser.add_option('-i', '--ip', dest='ip', help='IP address of PLC (CHECK THE DEFAULT VALUE)', default='192.168.223.100', type='string', metavar='IP')

parser.add_option('-p', '--port', dest='port', default=44818, help='TCP port to connect to (default: 44818)', type='int', metavar='INT')

parser.add_option('-t', '--test', dest='test', help='Test your connection', action='store_true', default=False)

parser.add_option('-R', '--remove_all', dest='remove_all', help='Remove all forces from relay outputs', action='store_true', default=False)


##### Student Options #####

parser.add_option('-P', '--prog', dest='prog', help='Put the PLC in program mode (assuming key is in REM position)', action='store_true', default=False)

parser.add_option('-r', '--run', dest='run', help='Put the PLC in run mode (assuming key is in REM position)', action='store_true', default=False)

parser.add_option('-f', '--forcelow', dest='forcelow', type='int', metavar='INT', help='Force an output Low')

parser.add_option('-F', '--forcehigh', dest='forcehigh', type='int', metavar='INT', help='Force an output High')



(options, args) = parser.parse_args()



# Connect to the PLC and register a session

e = ENIP()
e.connect(options.ip, options.port, 0)




##### CLI Implementation #####



# TODO: Info only
#
# Queries for status of PLC
# If everything is working you should see something like:
# b'o\x008\x00\xf40\xeb\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x02\x00\x00\x00\x00\x00\xb2\x00(\x00\xcb\x00\x00\x00\x07M\x00\x11-)\x04F\x00\xee\x03\x00\xeeJ\x9c#1763-LEC   \x00\x00&\x00Sp0\xfc\x01'
#
# Note the '1763-LEC'
#
if options.test:
	
	pccc_object = decode_hex('4b0220672401074d00112d29040600ee0303')
	
	response = e.send_pccc_object(pccc_object)
	print(response)


# Removes all forces on the output file 
# Not sure what all it affects, but it at least resets the relays
if options.remove_all:
	print('Removing all forces')
	
	# TODO: Info only
	# There are two ways to get the bytes from Wireshark
	# Either way works, but you have to format it appropriately
	#
	# This one is Copy -> ...as Escaped String
	# Note the b'...' 
	pccc_object = b'\x4b\x02\x20\x67\x24\x01\x07\x4d\x00\x11\x2d\x29\x04\x0f\x00\xc9\x5f\x63\x0f'
	
	# This one is Copy -> ...as a Hex String
	pccc_object = decode_hex('4b0220672401074d00112d29040f00c95f630f')
	
	response = e.send_pccc_object(pccc_object)





# TODO: Finish this function
# Changes PLC into Program Mode
if options.prog:
	# In Wireshark Copy -> ...as a Hex String (should start with 4b02...)
	pccc_object = decode_hex('')
	
	response = e.send_pccc_object(pccc_object)



# TODO: Finish this function
# Changes PLC into Run Mode	
if options.run:

	# In Wireshark Copy -> ...as a Hex String (should start with 4b02...)
	pccc_object = decode_hex('')
	
	response = e.send_pccc_object(pccc_object)
		




if not options.forcelow is None:
	
	# This is the index of the given output (i.e., O:0/[index])
	output_index = options.forcelow
	
	if output_index < 0 or output_index > 5:
		print('Output index out of range')
		exit()
	
	# TODO: Finish this function
	# you can start with a full message that forces a known output
	#
	# Once that works, try a few different outputs and see how the packets change.
	# Time-permitting, see if you can generalize this code to force any given Output
	#
	# Hint: some data fields that normally change from packet to packet
	# don't actually have to change. If you aren't
	# sure, try it first with the same value and see
	# if it gives you an error (check in Wireshark)
	# 

	# In Wireshark Copy -> ...as a Hex String (should start with 4b02...)
	pccc_object = decode_hex('')
	
	response = e.send_pccc_object(pccc_object)



if not options.forcehigh is None:
	
	# This is the index of the given output (i.e., O:0/[index])
	output_index = options.forcehigh
	
	if output_index < 0 or output_index > 5:
		print('Output index out of range')
		exit()
	
	# TODO: Finish this function
	# you can start with a full message that forces a known output
	#
	# Once that works, try a few different outputs and see how the packets change
	# Time-permitting, see if you can generalize this code to force any given Output
	#
	# Hint: some data fields that normally change from packet to packet
	# don't actually have to change. If you aren't
	# sure, try it first with the same value and see
	# if it gives you an error (check in Wireshark)
	# 

	# In Wireshark Copy -> ...as a Hex String (should start with 4b02...)
	pccc_object = decode_hex('')
	
	response = e.send_pccc_object(pccc_object)





	
	
	
	
	